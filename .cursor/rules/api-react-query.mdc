---
description: 
globs: 
alwaysApply: false
---
---
description: Create a Next.js API route and a fully typed React Query hook for fetching or mutating data, with shared types and error handling.
globs: ["src/pages/api/**/*.ts", "src/services/**/*.ts"]
alwaysApply: false
---

# ðŸ”Œ API + React Query Hook Boilerplate

## Purpose

Create an API route and a matching React Query hook, sharing types, with built-in error handling and proper separation of concerns.

## Guidelines

- API routes go in `pages/api/`
- Fetching logic goes in `src/services/`
- React Query hook lives in `src/hooks/`
- Use `TResponse` / `TRequest` for type safety
- Always wrap fetch calls with `try/catch`
- React Query keys should follow `['resource', params]` convention

## Example

### ðŸ”¹ 1. API Route â€“ `/pages/api/user/[id].ts`
```ts
import type { NextApiRequest, NextApiResponse } from 'next';

export type TUserResponse = {
  id: string;
  name: string;
};

export default function handler(req: NextApiRequest, res: NextApiResponse<TUserResponse | { error: string }>) {
  const { id } = req.query;

  if (typeof id !== 'string') {
    return res.status(400).json({ error: 'Invalid ID' });
  }

  // Simulate data fetch
  const user = { id, name: 'John Doe' };
  return res.status(200).json(user);
}
```

### ðŸ”¹ 2. Service â€“ /src/services/user.service.ts

``` ts
export const fetchUser = async (id: string) => {
  const res = await fetch(`/api/user/${id}`);
  if (!res.ok) throw new Error('Failed to fetch user');
  return res.json();
};
```

### ðŸ”¹ 3. React Query Hook â€“ /src/hooks/useUser.ts

``` ts
import { useQuery } from '@tanstack/react-query';
import { fetchUser } from '@/services/user.service';

export const useUser = (id: string) =>
  useQuery(['user', id], () => fetchUser(id), {
    enabled: !!id,
  });
```
